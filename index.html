<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Interactive BÃ©zier Rope</title>
<style>
  body {
    margin: 0;
    background: #0b0b0b;
    overflow: hidden;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

function normalize(v) {
  const len = Math.hypot(v.x, v.y) || 1;
  return { x: v.x / len, y: v.y / len };
}

function drawGrid(spacing = 50) {
  ctx.strokeStyle = "#1a1a1a";
  ctx.lineWidth = 1;

  for (let x = 0; x < canvas.width; x += spacing) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }

  for (let y = 0; y < canvas.height; y += spacing) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }
}

const P0 = { x: 100, y: canvas.height / 2 };
const P3 = { x: canvas.width - 100, y: canvas.height / 2 };

const P1 = { x: 300, y: 200, vx: 0, vy: 0 };
const P2 = { x: canvas.width - 300, y: 200, vx: 0, vy: 0 };

let target = { x: canvas.width / 2, y: canvas.height / 2 };

const stiffness = 0.08;
const damping = 0.75;

canvas.addEventListener("mousemove", (e) => {
  target.x = e.clientX;
  target.y = e.clientY;
});

function updateSpring(p, tx, ty) {
  const ax = -stiffness * (p.x - tx) - damping * p.vx;
  const ay = -stiffness * (p.y - ty) - damping * p.vy;

  p.vx += ax;
  p.vy += ay;

  p.x += p.vx;
  p.y += p.vy;
}

function bezier(t, p0, p1, p2, p3) {
  const u = 1 - t;
  const tt = t * t;
  const uu = u * u;

  return {
    x:
      uu * u * p0.x +
      3 * uu * t * p1.x +
      3 * u * tt * p2.x +
      tt * t * p3.x,
    y:
      uu * u * p0.y +
      3 * uu * t * p1.y +
      3 * u * tt * p2.y +
      tt * t * p3.y
  };
}

function bezierDerivative(t, p0, p1, p2, p3) {
  const u = 1 - t;
  return {
    x:
      3 * u * u * (p1.x - p0.x) +
      6 * u * t * (p2.x - p1.x) +
      3 * t * t * (p3.x - p2.x),
    y:
      3 * u * u * (p1.y - p0.y) +
      6 * u * t * (p2.y - p1.y) +
      3 * t * t * (p3.y - p2.y)
  };
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawGrid();

  ctx.setLineDash([5, 5]);
  ctx.strokeStyle = "#444";
  ctx.beginPath();
  ctx.moveTo(P0.x, P0.y);
  ctx.lineTo(P1.x, P1.y);
  ctx.lineTo(P2.x, P2.y);
  ctx.lineTo(P3.x, P3.y);
  ctx.stroke();
  ctx.setLineDash([]);

  ctx.lineWidth = 3;

  for (let t = 0; t < 1; t += 0.01) {
    const p1 = bezier(t, P0, P1, P2, P3);
    const p2 = bezier(t + 0.01, P0, P1, P2, P3);

    const d1 = normalize(bezierDerivative(t, P0, P1, P2, P3));
    const d2 = normalize(bezierDerivative(t + 0.01, P0, P1, P2, P3));

    const curvature =
      Math.hypot(d2.x - d1.x, d2.y - d1.y) * 300;

    ctx.strokeStyle = `rgb(${Math.min(255, curvature)}, 200, 255)`;

    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
  }

  const FRAME_LENGTH = 70;

  for (let t = 0.1; t <= 0.9; t += 0.1) {
    const p = bezier(t, P0, P1, P2, P3);
    const T = normalize(bezierDerivative(t, P0, P1, P2, P3));
    const N = { x: -T.y, y: T.x };

    ctx.strokeStyle = "#ff9800";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(p.x + T.x * FRAME_LENGTH, p.y + T.y * FRAME_LENGTH);
    ctx.stroke();

    ctx.strokeStyle = "#4fc3f7";
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(p.x + N.x * FRAME_LENGTH, p.y + N.y * FRAME_LENGTH);
    ctx.stroke();
  }

  // Control points
  [P0, P1, P2, P3].forEach((p, i) => {
    ctx.fillStyle = i === 0 || i === 3 ? "#f44336" : "#4caf50";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
    ctx.fill();
  });
}

function animate() {
  updateSpring(P1, target.x - 150, target.y);
  updateSpring(P2, target.x + 150, target.y);
  draw();
  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
